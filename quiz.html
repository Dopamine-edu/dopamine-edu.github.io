<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dopamine Quiz</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css" rel="stylesheet">
  <style>
    body { font-family: Arial, sans-serif; background: #f7f9fc; margin: 0; padding: 0; }
    .navbar { background: #667eea; padding: 15px 20px; }
    .navbar-brand { color: #fff; font-weight: bold; }
    .container { padding: 20px; }
    .header { margin-bottom: 20px; }
    #examNameDisplay { font-size: 1.8rem; font-weight: bold; margin-bottom: 10px; }
    #timer { background: #fff; padding: 10px; border-radius: 5px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 10px; }
    #scoreDisplay { font-size: 1.5rem; font-weight: bold; margin-bottom: 10px; }
    .question-card {
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .question-card p { margin-bottom: 10px; }
    .question-card label {
      display: block;
      padding: 10px;
      border-radius: 5px;
      transition: background 0.3s;
      margin-bottom: 5px;
      cursor: pointer;
    }
    .question-card label:hover { background: #f1f1f1; }
    /* Custom Radio Button Styling */
    input[type="radio"] {
      -webkit-appearance: none;
      appearance: none;
      margin-right: 8px;
      border: 2px solid #ccc;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      position: relative;
      cursor: pointer;
      vertical-align: middle;
    }
    input[type="radio"]:checked::after {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 8px;
      height: 8px;
      background: blue;
      border-radius: 50%;
    }
    input[type="radio"]:disabled {
      cursor: not-allowed;
      opacity: 1;
    }
    .correct { background-color: #c8e6c9; border: 2px solid #4caf50; }
    .incorrect { background-color: #ffcdd2; border: 2px solid #f44336; }
    .solution-explanation {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
      border-left: 4px solid #667eea;
      font-size: 0.9rem;
    }
    .stats-container { 
      margin-top: 10px; 
      padding: 15px; 
      background: #fff; 
      border-radius: 5px; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
    }
    .btn-primary { background-color: #667eea; border-color: #667eea; }
    .btn-primary:hover { background-color: #556cd6; border-color: #556cd6; }
    .loading-spinner { display: none; text-align: center; padding: 20px; color: #667eea; }
    .expired-message { text-align: center; color: #dc3545; font-size: 1.5rem; padding: 20px; }
    @media (max-width: 576px) {
      #examNameDisplay { font-size: 1.4rem; }
      .question-card label { font-size: 0.9rem; padding: 8px; }
      .solution-explanation { font-size: 0.8rem; padding: 8px; }
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Dopamine Quiz</a>
    </div>
  </nav>

  <div class="container">
    <div class="header">
      <div id="examNameDisplay">Loading...</div>
      <div id="timer">--:--</div>
      <div id="scoreDisplay" style="display: none;"></div>
      <div id="statsContainer" class="stats-container" style="display: none;"></div>
    </div>
    <div id="loading" class="loading-spinner">Loading Quiz...</div>
    <div id="expiredMessage" class="expired-message" style="display: none;"></div>
    <form id="examForm"></form>
    <div id="submitContainer" class="text-center mt-3">
      <button type="button" id="submitBtn" class="btn btn-primary">Submit</button>
    </div>
    <div id="solutionsContainer" class="mt-3"></div>
  </div>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBXXaWWoFqn6MpH6IWSm6CGaqUJzAmzbzA",
      authDomain: "dopamine-quiz.firebaseapp.com",
      projectId: "dopamine-quiz",
      storageBucket: "dopamine-quiz.firebasestorage.app",
      messagingSenderId: "822531459966",
      appId: "1:822531459966:web:8e7d2385090e997eb1c12f"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    let examParams = {
      examName: "Untitled Exam",
      timer: 1, // exam duration in minutes
      marksPerQuestion: 1,
      negativeMark: 0,
      lastDate: null
    };

    const urlParams = new URLSearchParams(window.location.search);
    const examId = urlParams.get("examId") || "default";
    const startTimeKey = "examStartTime_" + examId;
    const answersKey = "examAnswers_" + examId;
    const submittedFlagKey = "examSubmitted_" + examId;
    let savedAnswers = JSON.parse(localStorage.getItem(answersKey)) || {};
    let submitted = false;
    let timerRef;
    let allQuestions = [];

    function isExamExpired(lastDate) {
      if (!lastDate) return false;
      const examDeadline = new Date(lastDate);
      return new Date() > examDeadline;
    }

    function renderQuiz(questions, isReview = false, previousAnswers = {}) {
      allQuestions = questions;
      const examForm = document.getElementById("examForm");
      examForm.innerHTML = "";

      questions.forEach((q, idx) => {
        const questionDiv = document.createElement("div");
        questionDiv.className = "question-card";
        questionDiv.dataset.answer = q.correctOption;
        questionDiv.innerHTML = `<p class="fw-bold mb-3">${idx + 1}. ${q.question}</p>`;
        
        q.options.forEach((opt, optIdx) => {
          const label = document.createElement("label");
          const radioInput = document.createElement("input");
          radioInput.type = "radio";
          radioInput.name = "q" + idx;
          radioInput.value = String(optIdx + 1);
          
          if (isReview) {
            radioInput.disabled = true;
            if (previousAnswers["q" + idx] === radioInput.value) {
              radioInput.checked = true;
              if (radioInput.value === q.correctOption) {
                label.classList.add("correct");
              } else {
                label.classList.add("incorrect");
              }
            } else if (radioInput.value === q.correctOption) {
              label.classList.add("correct");
            }
          } else {
            if (savedAnswers["q" + idx] && savedAnswers["q" + idx + "_locked"]) {
              if (savedAnswers["q" + idx] === radioInput.value) {
                radioInput.checked = true;
              }
              radioInput.disabled = true;
            }
            radioInput.addEventListener("change", () => {
              if (!savedAnswers["q" + idx + "_locked"]) {
                savedAnswers["q" + idx] = radioInput.value;
                savedAnswers["q" + idx + "_locked"] = true;
                // Lock all options for this question
                const radios = document.getElementsByName("q" + idx);
                Array.from(radios).forEach(radio => {
                  radio.disabled = true;
                });
                radioInput.checked = true;
                localStorage.setItem(answersKey, JSON.stringify(savedAnswers));
              }
            });
          }
          label.appendChild(radioInput);
          label.appendChild(document.createTextNode(" " + opt));
          questionDiv.appendChild(label);
        });
        examForm.appendChild(questionDiv);
      });

      // Only start the timer if we are not in review mode.
      if (!isReview && !timerRef) startTimer();
    }

    function startTimer() {
      const timerElement = document.getElementById("timer");
      let storedStart = localStorage.getItem(startTimeKey);
      if (!storedStart) {
        storedStart = Date.now();
        localStorage.setItem(startTimeKey, storedStart);
      } else {
        storedStart = parseInt(storedStart, 10);
      }
      const examDurationMs = examParams.timer * 60 * 1000;
      let remainingMs = examDurationMs - (Date.now() - storedStart);
      if (remainingMs < 0) remainingMs = 0;
      let timeLeft = Math.floor(remainingMs / 1000);

      timerRef = setInterval(() => {
        if (timeLeft <= 0) {
          clearInterval(timerRef);
          if (!submitted) submitExam();
        } else {
          const minutes = Math.floor(timeLeft / 60);
          const seconds = timeLeft % 60;
          timerElement.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
          timeLeft--;
        }
      }, 1000);
    }

    function submitExam() {
      if (submitted) return;
      submitted = true;
      clearInterval(timerRef);

      let score = 0, correctCount = 0, wrongCount = 0;
      const questionDivs = document.querySelectorAll(".question-card");
      const totalQuestions = questionDivs.length;

      questionDivs.forEach((qDiv, idx) => {
        const correctAnswer = qDiv.dataset.answer;
        const selectedOption = qDiv.querySelector("input[type='radio']:checked");
        if (selectedOption) {
          if (selectedOption.value === correctAnswer) {
            score += examParams.marksPerQuestion;
            correctCount++;
            selectedOption.parentElement.classList.add("correct");
          } else {
            wrongCount++;
            selectedOption.parentElement.classList.add("incorrect");
            qDiv.querySelectorAll("label").forEach(label => {
              if (label.querySelector("input").value === correctAnswer) {
                label.classList.add("correct");
              }
            });
          }
        } else {
          wrongCount++;
          qDiv.querySelectorAll("label").forEach(label => {
            if (label.querySelector("input").value === correctAnswer) {
              label.classList.add("correct");
            }
          });
        }
      });

      document.getElementById("scoreDisplay").style.display = "block";
      document.getElementById("scoreDisplay").innerHTML = `Your Score: ${score} / ${totalQuestions}`;
      document.getElementById("statsContainer").style.display = "block";
      document.getElementById("statsContainer").innerHTML = `
        <p class="text-success fw-bold">Correct Answers: ${correctCount}</p>
        <p class="text-danger fw-bold">Wrong Answers: ${wrongCount}</p>
      `;

      questionDivs.forEach((qDiv, idx) => {
        const explanation = allQuestions[idx].explanation;
        if (explanation && explanation.trim() !== "") {
          const explanationDiv = document.createElement("div");
          explanationDiv.className = "solution-explanation";
          explanationDiv.innerHTML = `<strong>Explanation:</strong> ${explanation}`;
          qDiv.appendChild(explanationDiv);
        }
      });

      document.getElementById("submitContainer").style.display = "none";
      document.getElementById("timer").style.pointerEvents = "none";

      // Remove exam timing keys and mark exam as submitted.
      localStorage.removeItem(startTimeKey);
      localStorage.removeItem(answersKey);
      localStorage.setItem(submittedFlagKey, "true");

      // Save exam result to Firestore (if examId exists)
      if (examId !== "default") {
        const userId = auth.currentUser.uid;
        db.collection("examResults").add({
          userId: userId,
          examId: examId,
          examName: examParams.examName,
          score: score,
          correctCount: correctCount,
          wrongCount: wrongCount,
          answers: savedAnswers,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        })
        .then(() => {
          Toastify({
            text: "Results saved successfully!",
            duration: 3000,
            style: { background: "#667eea" }
          }).showToast();
        })
        .catch((error) => {
          console.error("Error saving exam result:", error);
          Toastify({
            text: "Error saving results",
            duration: 3000,
            style: { background: "#dc3545" }
          }).showToast();
        });
      }
    }

    // Check exam status on auth state change.
    auth.onAuthStateChanged((user) => {
      const loadingDiv = document.getElementById("loading");
      loadingDiv.style.display = "block";
      if (!user) {
        window.location.href = "auth.html";
      } else {
        if (examId) {
          // If exam already submitted (flag in localStorage), load review mode.
          if (localStorage.getItem(submittedFlagKey) === "true") {
            db.collection("examResults")
              .where("userId", "==", user.uid)
              .where("examId", "==", examId)
              .get()
              .then((querySnapshot) => {
                if (!querySnapshot.empty) {
                  const resultDoc = querySnapshot.docs[0].data();
                  db.collection("exams").doc(examId).get()
                    .then((doc) => {
                      loadingDiv.style.display = "none";
                      if (doc.exists) {
                        const examData = doc.data();
                        examParams.examName = examData.examName || examParams.examName;
                        examParams.timer = examData.timer || examParams.timer;
                        examParams.marksPerQuestion = examData.marksPerQuestion || examParams.marksPerQuestion;
                        examParams.negativeMark = examData.negativeMark || examParams.negativeMark;
                        examParams.lastDate = examData.lastDate || null;
                        document.getElementById("examNameDisplay").innerText = examParams.examName;
                        
                        const questionIds = examData.questions || [];
                        Promise.all(questionIds.map(qid => db.collection("questions").doc(qid).get()))
                          .then((docs) => {
                            const questions = docs.filter(doc => doc.exists).map(doc => ({ id: doc.id, ...doc.data() }));
                            displayReviewMode(questions, resultDoc);
                          })
                          .catch((error) => {
                            console.error("Error loading review questions:", error);
                            Toastify({
                              text: "Error loading review data",
                              duration: 3000,
                              style: { background: "#dc3545" }
                            }).showToast();
                          });
                      }
                    });
                }
              })
              .catch((error) => {
                console.error("Error checking exam result:", error);
                Toastify({
                  text: "Error checking exam status",
                  duration: 3000,
                  style: { background: "#dc3545" }
                }).showToast();
              });
          } else {
            // If not yet submitted, check Firestore for exam result.
            db.collection("examResults")
              .where("userId", "==", user.uid)
              .where("examId", "==", examId)
              .get()
              .then((querySnapshot) => {
                if (!querySnapshot.empty) {
                  const resultDoc = querySnapshot.docs[0].data();
                  db.collection("exams").doc(examId).get()
                    .then((doc) => {
                      loadingDiv.style.display = "none";
                      if (doc.exists) {
                        const examData = doc.data();
                        examParams.examName = examData.examName || examParams.examName;
                        examParams.timer = examData.timer || examParams.timer;
                        examParams.marksPerQuestion = examData.marksPerQuestion || examParams.marksPerQuestion;
                        examParams.negativeMark = examData.negativeMark || examParams.negativeMark;
                        examParams.lastDate = examData.lastDate || null;
                        document.getElementById("examNameDisplay").innerText = examParams.examName;

                        const questionIds = examData.questions || [];
                        Promise.all(questionIds.map(qid => db.collection("questions").doc(qid).get()))
                          .then((docs) => {
                            const questions = docs.filter(doc => doc.exists).map(doc => ({ id: doc.id, ...doc.data() }));
                            displayReviewMode(questions, resultDoc);
                          })
                          .catch((error) => {
                            console.error("Error loading exam questions for review:", error);
                            Toastify({
                              text: "Error loading review data",
                              duration: 3000,
                              style: { background: "#dc3545" }
                            }).showToast();
                          });
                      }
                    });
                } else {
                  // New exam: fetch exam questions normally
                  db.collection("exams").doc(examId).get()
                    .then((doc) => {
                      loadingDiv.style.display = "none";
                      if (doc.exists) {
                        const examData = doc.data();
                        examParams.examName = examData.examName || examParams.examName;
                        examParams.timer = examData.timer || examParams.timer;
                        examParams.marksPerQuestion = examData.marksPerQuestion || examParams.marksPerQuestion;
                        examParams.negativeMark = examData.negativeMark || examParams.negativeMark;
                        examParams.lastDate = examData.lastDate || null;
                        document.getElementById("examNameDisplay").innerText = examParams.examName;

                        if (isExamExpired(examParams.lastDate)) {
                          document.getElementById("expiredMessage").style.display = "block";
                          document.getElementById("expiredMessage").innerText = "This exam is expired. You cannot participate.";
                          document.getElementById("examForm").style.display = "none";
                          document.getElementById("submitContainer").style.display = "none";
                          return;
                        }

                        const questionIds = examData.questions || [];
                        if (questionIds.length === 0) {
                          document.getElementById("examForm").innerHTML = "<p>No questions selected for this exam.</p>";
                          return;
                        }

                        Promise.all(questionIds.map(qid => db.collection("questions").doc(qid).get()))
                          .then((docs) => {
                            const questions = docs.filter(doc => doc.exists).map(doc => ({ id: doc.id, ...doc.data() }));
                            renderQuiz(questions);
                            Toastify({
                              text: "Quiz loaded successfully!",
                              duration: 3000,
                              style: { background: "#667eea" }
                            }).showToast();
                          })
                          .catch((error) => {
                            console.error("Error loading exam questions:", error);
                            document.getElementById("examForm").innerHTML = "<p>Error loading exam questions.</p>";
                            Toastify({
                              text: "Error loading questions",
                              duration: 3000,
                              style: { background: "#dc3545" }
                            }).showToast();
                          });
                      } else {
                        loadDefaultQuestions();
                      }
                    })
                    .catch((error) => {
                      console.error("Error retrieving exam:", error);
                      loadDefaultQuestions();
                    });
                }
              })
              .catch((error) => {
                console.error("Error checking exam result:", error);
                Toastify({
                  text: "Error checking exam status",
                  duration: 3000,
                  style: { background: "#dc3545" }
                }).showToast();
              });
          }
        } else {
          loadDefaultQuestions();
        }
      }
    });

    function loadDefaultQuestions() {
      db.collection("questions").orderBy("timestamp", "desc").limit(50).get()
        .then((querySnapshot) => {
          const questions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          renderQuiz(questions);
        })
        .catch((error) => {
          console.error("Error retrieving questions:", error);
          document.getElementById("examForm").innerHTML = "<p>Error retrieving questions.</p>";
          Toastify({
            text: "Error loading default questions",
            duration: 3000,
            style: { background: "#dc3545" }
          }).showToast();
        });
    }
    
    // Review mode: similar to renderQuiz but without timer and with disabled inputs
    function displayReviewMode(questions, resultData) {
      const examForm = document.getElementById("examForm");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const statsContainer = document.getElementById("statsContainer");
      const solutionsContainer = document.getElementById("solutionsContainer");
      const submitContainer = document.getElementById("submitContainer");
      const timer = document.getElementById("timer");

      timer.style.display = "none";
      renderQuiz(questions, true, resultData.answers || {});
      scoreDisplay.style.display = "block";
      scoreDisplay.innerHTML = `Your Score: ${resultData.score} / ${questions.length}`;
      statsContainer.style.display = "block";
      statsContainer.innerHTML = `
        <p class="text-success fw-bold">Correct Answers: ${resultData.correctCount}</p>
        <p class="text-danger fw-bold">Wrong Answers: ${resultData.wrongCount}</p>
      `;

      solutionsContainer.innerHTML = "";
      questions.forEach((q, idx) => {
        const questionDiv = document.createElement("div");
        questionDiv.className = "question-card";
        questionDiv.innerHTML = `
          <p class="fw-bold">${idx + 1}. ${q.question}</p>
          ${q.options.map((opt, optIdx) => {
            const isUserAnswer = resultData.answers["q" + idx] === String(optIdx + 1);
            const isCorrect = String(optIdx + 1) === q.correctOption;
            let className = "";
            if (isUserAnswer) {
              className = isCorrect ? "correct" : "incorrect";
            } else if (isCorrect) {
              className = "correct";
            }
            return `<label><input type="radio" name="q${idx}" value="${optIdx + 1}" disabled ${isUserAnswer || isCorrect ? "checked" : ""}> ${opt}</label>`;
          }).join("")}
          ${q.explanation && q.explanation.trim() !== "" ? 
            `<div class="solution-explanation"><strong>Explanation:</strong> ${q.explanation}</div>` : ""}
        `;
        solutionsContainer.appendChild(questionDiv);
      });
      submitContainer.style.display = "none";
      Toastify({
        text: "Showing your previous submission",
        duration: 3000,
        style: { background: "#667eea" }
      }).showToast();
    }
  </script>
</body>
</html>
